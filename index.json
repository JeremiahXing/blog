[{"content":"Multi-dimensional arrays in C can be somewhat confusing, especially when it comes to pointers and memory layout. This blog post aims to give beginners in C a kick-off and disenchant these concepts. In my humble opinion, if you master the pointers, you master the core concept of C language.\nBefore Starting: This post is inspiried by this question on stackoverflow. For an easy kick-off, better if you already have these pre-knowledges (but no worries if you don\u0026rsquo;t, I\u0026rsquo;ll share some links): basic understanding of memory address \u0026amp; pointers in C: https://www.w3schools.com/c/c_memory_address.php https://www.w3schools.com/c/c_pointers.php an array (whatever how many dimensions it is) in C as long as it\u0026rsquo;s a static allocated array is stored contiguously in memory. So this means the compiler will treat the 2D array matrix[3][3] as a 1D array if you don\u0026rsquo;t explicitly tell the compiler to treat it like a 2D one. (might be confusing but I\u0026rsquo;ll explain it with examples) an online IDE with compiler that might come in handy: jdoodle C What\u0026rsquo;s the Issue? Let\u0026rsquo;s understand the problem first, here\u0026rsquo;s a C code snippet with bugs.\nDon\u0026rsquo;t worry what does the convert_to_csr do. You just need to focus on its arguments.\n#include\u0026lt;stdio.h\u0026gt; void convert_to_csr(int **matrix, size_t row_len, size_t col_len){ printf(\u0026#34;first value of array %d\\n\u0026#34;, **matrix); } int main(void) { int matrix[3][3] = { {0, 1, 0}, {0, 0, 1}, {0, 1, 0} }; printf(\u0026#34;matrix first value outside func %d\\n\u0026#34;, matrix[0][0]); convert_to_csr(matrix, 3, 3); } Simply copy and paste it to the jdoodle online C compiler and run it. A error will pop-up like Command terminated by signal 11 which aka SIGSEGV. The error appears when a program or code tries to access an invalid memory location.\nWhy SIGSEGV Happens? Now let\u0026rsquo;s break down these different kinds of \u0026ldquo;pointers\u0026rdquo; in C to understand the problem:\nA Normal Pointer (like int*): int* ptr: A pointer in C is a variable that holds the memory address of another variable. Size of a pointer jump: ptr++ in int *ptr moves the pointer by sizeof(int) bytes. Array Name: int arr[5]: in this case arr is not exactly a 100% pointer. As this \u0026ldquo;pointer\u0026rdquo; does not allow the increment operation (++). This is because arrays are not modifiable l-values in C. However, you can use a new pointer int* ptr = arr as in C, the name of an array can be used as a pointer to its first element. Size of a pointer jump: ptr++ in this case moves the pointer by sizeof(int) bytes; And if it\u0026rsquo;s a 2D array int arr[5][5]: Then the first element is an int[5] array, so a pointerizion in this case should be: int (*ptr)[5] = arr. Size of a pointer jump: ptr++ in this case moves the pointer by 5 * sizeof(int) bytes. A Pointer to Pointer: int ** ptr: A pointer to pointer in C is a variable that holds the memory address of another pointer. Size of a pointer jump: ptr++ in int **ptr moves the pointer by sizeof(int*) bytes aka a poniter\u0026rsquo;s size. So The function convert_to_csr is expecting a parameter of type int**, which is a pointer to a pointer to an int. This is fundamentally different from int (*)[3] in terms of memory layout and how the pointer arithmetic works. That\u0026rsquo;s why the error has been thrown.\nI know it might be confusing, lets come back to this \u0026ldquo;a static array (whatever how many dimensions it is) in C is stored contiguously in memory\u0026rdquo; and \u0026ldquo;the compiler will treat the 2D array matrix[3][3] as a 1D array if you don\u0026rsquo;t explicitly tell the compiler to treat it like a 2D one\u0026rdquo;.\nHere\u0026rsquo;s a perfect example to explain everything, please run the following code:\n#include\u0026lt;stdio.h\u0026gt; int main(void) { int matrix[3][3] = { {0, 1, 0}, {0, 0, 1}, {0, 1, 0} }; int **ptr1 = matrix; int (*ptr2)[3] = matrix; printf(\u0026#34;ptr1: %p\\n\u0026#34;, ptr1); printf(\u0026#34;ptr2: %p\\n\u0026#34;, ptr2); printf(\u0026#34;*ptr1: %p\\n\u0026#34;, *ptr1); printf(\u0026#34;*ptr2: %p\\n\u0026#34;, *ptr2); return 0; } You can get the output like:\nptr1: 0x7ffe5261a090 ptr2: 0x7ffe5261a090 *ptr1: 0x100000000 *ptr2: 0x7ffe5261a090 Your ptr1, ptr2,and *ptr2 might be different than mine (as we run on different machine) but the third line *ptr1: 0x100000000 should be the same and it doesn\u0026rsquo;t looks like an actual address at all.\nThis is what I mean by \u0026ldquo;the compiler treat it like a 1D array if you don\u0026rsquo;t tell it\u0026rdquo;. So when you dereference ptr1 using *ptr1, you\u0026rsquo;re treating the value at matrix[0][0] as a pointer (since ptr1 is an int**). This is why you get a strange and seemingly unrelated memory address, like 0x100000000. It\u0026rsquo;s interpreting the integer value at matrix[0][0] (which is 0) as a memory address, leading to a sig fault.\nPlease notice that operation like int **ptr1 = matrix; is actually problematic and should not compile without a warning or error in standard C. ptr1 is a pointer to a pointer to an int, but matrix is a 2D array (specifically, an array of arrays of int). In C, these are not compatible types, as the memory layout they expect is different. If your compiler allows this assignment, it\u0026rsquo;s doing so without proper type checking, which is unsafe.\nint ** arr is typically used for a dynamically allocated 2D array (malloc()) where each row is an independently allocated array of integers, and arr points to an array of pointers, each pointing to one of these rows.\nWhat\u0026rsquo;s the Solutions? A generic solution in C for passing 2D or multi-dimensional array as paramenter is using void* pointer.\nBut please be careful because void* pointers lack any information about the type they point to, like the pointered-to variable\u0026rsquo;s size. So when working with void* pointers, you have to explicitly manage the pointer arithmetic and type casting.\nAn example using void* in this case is:\n#include\u0026lt;stdio.h\u0026gt; void convert_to_csr(void *matrix, size_t row_len, size_t col_len){ // Cast the void pointer to the correct type, which is a pointer to an array of int[col_len] int (*mat)[col_len] = matrix; // Now, mat can be used as a 2D array // Some 2D array accessing operations for (size_t i = 0; i \u0026lt; row_len; ++i) { for (size_t j = 0; j \u0026lt; col_len; ++j) { printf(\u0026#34;%d \u0026#34;, mat[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main(void) { int matrix[3][3] = { {0, 1, 0}, {0, 0, 1}, {0, 1, 0} }; printf(\u0026#34;Matrix first value outside func: %d\\n\u0026#34;, matrix[0][0]); // Passing the matrix as a void pointer convert_to_csr(matrix, 3, 3); return 0; } This void* approach could be useful if your compiler doesn\u0026rsquo;t support variable length array arguments.\nOr this will work as well, but it uses some magic number in convert_to_csr declaration so I don\u0026rsquo;t really like it.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void convert_to_csr(int (*matrix)[3], size_t row_len, size_t col_len) { // Example: Print elements to demonstrate correct access for (size_t i = 0; i \u0026lt; row_len; i++) { for (size_t j = 0; j \u0026lt; col_len; j++) { printf(\u0026#34;%d \u0026#34;, matrix[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main(void) { int matrix[3][3] = { {0, 1, 0}, {0, 0, 1}, {0, 1, 0} }; printf(\u0026#34;Matrix first value outside func: %d\\n\u0026#34;, matrix[0][0]); convert_to_csr(matrix, 3, 3); return 0; } Or if your compiler supports variable length arrays then you can declare the convert_to_csr function like:\n#include \u0026lt;stdio.h\u0026gt; void convert_to_csr(size_t row_len, size_t col_len, int matrix[row_len][col_len]){ for (size_t i = 0; i \u0026lt; row_len; i++) { for (size_t j = 0; j \u0026lt; col_len; j++) { printf(\u0026#34;%d \u0026#34;, matrix[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main(void) { int matrix[3][3] = { {0, 1, 0}, {0, 0, 1}, {0, 1, 0} }; printf(\u0026#34;matrix first value outside func %d\\n\u0026#34;, matrix[0][0]); convert_to_csr(3, 3, matrix); } This is a cleaner and more straightforward way of handling arrays of varying sizes in C, provided that the compiler supports C99 or later standards.\nLast Talking Cock: If you understand the pointers and mutidimentional arrays in C, you already A MASTER OF C! üíÉüèªüíÉüèªüíÉüèªüï∫üèªüï∫üèªüï∫üèª\nLol but honestly, in C there\u0026rsquo;s not necessary many cool stuffs (like vector in C++ or GC in Java). That why you might find C usually under the shadow of C++ü•≤.\nEven though, I reckon that understanding that Memory Allocation stuff is critical for learning whatever kinds of programming languages. It\u0026rsquo;s not just the language but the mindset as a programmer.\nFor an advanced understanding of C, computer architecture, compilation principle and even a bit linux system kernel, please have a look at CMU 15-213: CSAPP. It\u0026rsquo;s not easy, but no cap that it\u0026rsquo;s my first inspired course in computer science study jounery. It indeed cooked most of the fundamentals you need to know in computer science. Its reputation is well deserivedüôÇ.\nSome References: StackOverflow: passing double pointers as 2d arrays in C GeeksforGeeks: lvalue and rvalue in C language CppReference: C99 variable length arrays CMU 15-213: CSAPP ","permalink":"https://jrmh.dev/posts/md_arrays_in_c/","summary":"Multi-dimensional arrays in C can be somewhat confusing, especially when it comes to pointers and memory layout. This blog post aims to give beginners in C a kick-off and disenchant these concepts. In my humble opinion, if you master the pointers, you master the core concept of C language.\nBefore Starting: This post is inspiried by this question on stackoverflow. For an easy kick-off, better if you already have these pre-knowledges (but no worries if you don\u0026rsquo;t, I\u0026rsquo;ll share some links): basic understanding of memory address \u0026amp; pointers in C: https://www.","title":"Multidimensional Arrays and Pointers in C"},{"content":"In Linux, these concepts are foundational: You will see lots of faces in the list (like Mounts, Processes, \u0026hellip;) while using containerization tools like Docker. Processes: These are running instances of programs. Linux manages them, allocating resources and scheduling their execution. Mounts: This refers to attaching a file system to a directory, enabling access to files in storage. chroot/pivot_root: These are methods to change the root directory. chroot changes the perceived root directory for a process, while pivot_root is used in system initialization, replacing the old root with a new one. CoW Storage (Copy-on-Write): A resource-management technique where system resources are shared and copied only when modified, optimizing performance and memory usage. Users: In Linux, users are entities with permissions to access and manipulate files and processes. Each user has a unique ID. Namespaces: These are used to isolate processes, ensuring they only see certain system resources. They\u0026rsquo;re key in containerization, allowing safe and secure multitasking. Memory Management: Linux efficiently manages memory through techniques like paging and swapping, ensuring optimal use of RAM and storage resources for process execution. For More Details:\nLinux Primitives Slides (Credits and Acknowlegement: Nati Cohen, Avishai Ish-Shalom) The Linux Kernel Documentation Linux man page ","permalink":"https://jrmh.dev/posts/linux_primitives/","summary":"In Linux, these concepts are foundational: You will see lots of faces in the list (like Mounts, Processes, \u0026hellip;) while using containerization tools like Docker. Processes: These are running instances of programs. Linux manages them, allocating resources and scheduling their execution. Mounts: This refers to attaching a file system to a directory, enabling access to files in storage. chroot/pivot_root: These are methods to change the root directory. chroot changes the perceived root directory for a process, while pivot_root is used in system initialization, replacing the old root with a new one.","title":"Linux Primitives"},{"content":"Introduction In our interconnected digital age, it\u0026rsquo;s crucial to access our devices securely from any location. This guide will walk you through setting up a VPN with Tailscale, facilitating a seamless and secure connection between an Ubuntu desktop (acting as the server) and a MacBook.\nFor those in a hurry, jump straight to the instructions. If you\u0026rsquo;re curious, here are some Q\u0026amp;As:\nWhat is SSH? How does SSH help us develop remotely? What is a VPN? Why use SSH and VPN in combination? Setting this up might seem daunting, so I use Tailscale to make my life easier.\nInstall Tailscale First, install Tailscale on both your SSH server and client. MacBook users take note: There are three methods to run Tailscale on macOS. For an enhanced user experience, please install the open-source Tailscale \u0026amp; Tailscaled CLI version. The GUI version, unfortunately, doesn\u0026rsquo;t operate in the background.\nAll the installation instructions can be found here.\nConnect Your Devices and Set Up Tailscale SSH After installation, connecting your devices is straightforward. Just follow the on-screen instructions.\nThis guide uses Tailscale\u0026rsquo;s SSH service for the connection, which is both user-friendly and secure. Dive deeper into the nuances of Tailscale SSH.\nHowever, if you prefer, you can use the OpenSSH Server and client paired with the Tailscale VPN instead of Tailscale\u0026rsquo;s SSH service. This approach is slightly trickier to configure securely.\nOn Ubuntu:\nsudo tailscale up --ssh On Mac (with the Tailscale CLI version):\ntailscale up Once you\u0026rsquo;ve linked the devices, you\u0026rsquo;ll see an output resembling the following: The IP address is auto-allocated by Tailscale once your device gets connected. (and for sure it‚Äôs not 127.0.0.1 Lol)\nConnect Your Devices in IDE Once you get there, in your client device terminal, use the below command to connect:\nssh \u0026lt;username\u0026gt;@\u0026lt;server device vpn ip adress\u0026gt; Replace \u0026lt;username\u0026gt; with a valid user from your SSH server system.\nIf you\u0026rsquo;ve managed to connect successfully using SSH, you might want to set up an SSH connection within your favorite IDE for a smoother remote development experience. Personally, I use vscode, and you can find setup instructions here.\nHere\u0026rsquo;s a glimpse of the vscode SSH connection terminal on my laptop:\n","permalink":"https://jrmh.dev/posts/ssh_tailscale/","summary":"Introduction In our interconnected digital age, it\u0026rsquo;s crucial to access our devices securely from any location. This guide will walk you through setting up a VPN with Tailscale, facilitating a seamless and secure connection between an Ubuntu desktop (acting as the server) and a MacBook.\nFor those in a hurry, jump straight to the instructions. If you\u0026rsquo;re curious, here are some Q\u0026amp;As:\nWhat is SSH? How does SSH help us develop remotely?","title":"Secure and Low-latency SSH Connection: Setting Up via Tailscale"},{"content":"What is awk? awk is a powerful scripting language and command-line utility for text-processing in Unix/Linux environments. It scans each line of a file, looking for patterns that match, and then processes the line accordingly (kinda like reduce in JavaScript but has difference). It\u0026rsquo;s excellent for manipulating structured text data like CSV, logs, or even simple text files.\nBasic Syntax The basic syntax of awk is:\nawk \u0026#39;pattern {action}\u0026#39; file pattern: A condition to match (like regex or conditional expressions). If omitted, awk processes all lines. action: Commands to execute when a pattern matches. Actions are enclosed in {}. Types of Patterns in awk Regular Expressions: Use regular expressions as patterns to match lines. Example: awk '/error/ {print}' file.txt prints lines containing \u0026ldquo;error\u0026rdquo;.\nRelational Expressions: These include comparisons of numbers or strings. Example: awk '$2 \u0026gt; 100 {print}' file.txt prints lines where the second field is greater than 100.\nCompound Patterns: Combine patterns using logical operators (\u0026amp;\u0026amp;, ||, !). Example: awk '$1 == \u0026quot;start\u0026quot; \u0026amp;\u0026amp; $3 \u0026gt; 50 {print}' file.txt prints lines where the first field is \u0026ldquo;start\u0026rdquo; and the third field is over 50.\nRange Patterns: Match lines from the start pattern to the end pattern. Example: awk '/start/, /end/ {print}' file.txt prints lines from \u0026ldquo;start\u0026rdquo; to \u0026ldquo;end\u0026rdquo;.\nSpecial Patterns BEGIN and END: BEGIN: Executed before reading any input lines, often for initialization. END: Executed after all lines are processed, used for summaries or conclusions.\nExample Problem: Word Frequency Let\u0026rsquo;s use LeetCode 192. Word Frequency: write a bash script to calculate the frequency of each word in a text file words.txt as a example.\nThe solution of this problem is straight forward, bascially in 3 steps:\nRead the file words.txt; Walk through each word, record/update the frequencey; Sort and print out the result. However, implementing this in a shell script can be hard, especially for people who aren\u0026rsquo;t familiar with Linux Shell Script. It\u0026rsquo;s even more challenging if you want to write it in a single line of script code (and yeah all Linux developers do it cause it looks cool af XD)\nBut no worries, let\u0026rsquo;s break the damn thing down with Shell Pipe. If you don\u0026rsquo;t know what it is, I have another blog about that and feel free to check it out.\nSolution: Read the File cat words.txt\nThis command reads the content of the file words.txt. cat is short for concatenate. When used with a file name, it displays the content of the file.\necho -e $(...)\nThe $(...) is command substitution, which means it executes the command inside the parentheses and then echo outputs the result. echo -e enables interpretation of backslash escapes. When used with the output of cat words.txt, it converts newlines into spaces. This effectively puts all the words on a single line.\nUpdate frequencey This awk script is the core part of the command.\nfor(i=1; i\u0026lt;=NF; i++){words[$i]++}: This loop iterates over all fields (words) in a line. NF is a built-in variable in awk that represents the number of fields in the current record (line). For each word, it increments the count in the associative array words.\nEND {for(w in words) print w, words[w]}: After processing all lines, this part executes. It iterates through each index (word) in the array words and prints the word and its frequency.\nSort and Print sort -k2 -n -r\nThis sorts the output from the awk command. -k2 tells sort to sort based on the second column (which is the word frequency). -n means to sort numerically (since word counts are numbers). -r sorts in reverse order, so you get a list from the most frequent to the least frequent word.\necho -e $(cat words.txt) | awk \u0026#39;{for(i=1; i\u0026lt;=NF; i++){words[$i]++}} END {for(w in words) print w, words[w]}\u0026#39; | sort -k2 -n -r ","permalink":"https://jrmh.dev/posts/bash_awk/","summary":"What is awk? awk is a powerful scripting language and command-line utility for text-processing in Unix/Linux environments. It scans each line of a file, looking for patterns that match, and then processes the line accordingly (kinda like reduce in JavaScript but has difference). It\u0026rsquo;s excellent for manipulating structured text data like CSV, logs, or even simple text files.\nBasic Syntax The basic syntax of awk is:\nawk \u0026#39;pattern {action}\u0026#39; file pattern: A condition to match (like regex or conditional expressions).","title":"Understand awk in Linux Shell"},{"content":"Shell pipes are a powerful feature of command-line interfaces in Unix and Unix-like systems, including Linux and macOS. They allow you to pass the output of one command directly into another command, creating a \u0026ldquo;pipeline\u0026rdquo; of operations. This can greatly simplify your tasks and enable efficient data processing. In this post, we\u0026rsquo;ll explore the basics of shell pipes and see some practical examples.\nWhat is a Shell Pipe? A shell pipe, denoted by the | symbol, takes the output (stdout) of one command and uses it as the input (stdin) for the next command. This chaining of commands allows you to perform complex tasks with a combination of simple commands.\nBasic Example of Using a Pipe Consider a situation where you have a file named names.txt containing a list of names, and you want to find out how many names are in the file. You can use a combination of cat, grep, and wc commands:\ncat names.txt | grep -v \u0026#34;^#\u0026#34; | wc -l In this command:\ncat names.txt displays the content of names.txt. grep -v \u0026quot;^#\u0026quot; filters out lines starting with # (comments, for instance). wc -l counts the number of lines. The pipe | passes the output of each command to the next. Pipes are particularly useful for sorting and filtering data. For example, if you want to list all files in the current directory, sorted by file size:\nls -l | sort -nk5 This command:\nls -l lists files in long format. sort -nk5 sorts the output numerically (-n) based on the fifth column (-k5), which is the file size. You can also chain multiple pipes together. Suppose you want to check the most used words in a text file:\ncat article.txt | tr \u0026#39; \u0026#39; \u0026#39;\\n\u0026#39; | sort | uniq -c | sort -nr | head -10 This breaks down as:\ncat article.txt displays the file content. tr ' ' '\\n' replaces spaces with new lines, putting each word on a separate line. sort sorts the words alphabetically. uniq -c counts the occurrences of each word. sort -nr sorts the word count in descending order. head -10 shows the top 10 results. Conclusion Shell pipes are a simple yet powerful tool for processing and manipulating data on the command line. By understanding and using pipes, you can combine basic commands to perform complex tasks efficiently.\n","permalink":"https://jrmh.dev/posts/bash_pipe/","summary":"Shell pipes are a powerful feature of command-line interfaces in Unix and Unix-like systems, including Linux and macOS. They allow you to pass the output of one command directly into another command, creating a \u0026ldquo;pipeline\u0026rdquo; of operations. This can greatly simplify your tasks and enable efficient data processing. In this post, we\u0026rsquo;ll explore the basics of shell pipes and see some practical examples.\nWhat is a Shell Pipe? A shell pipe, denoted by the | symbol, takes the output (stdout) of one command and uses it as the input (stdin) for the next command.","title":"Shell Pipes: Simplifying Command Line Tasks"},{"content":" Multidimensional Arrays and Pointers in C TBC\u0026hellip; ","permalink":"https://jrmh.dev/editors-picks/c_cpp/","summary":" Multidimensional Arrays and Pointers in C TBC\u0026hellip; ","title":"C/C++"},{"content":" A Self-learning Guide for Computer Science: csdiy.wiki freeCodeCamp TBC\u0026hellip; ","permalink":"https://jrmh.dev/editors-picks/cs-self-study/","summary":" A Self-learning Guide for Computer Science: csdiy.wiki freeCodeCamp TBC\u0026hellip; ","title":"CS Self-Study Guides for Reference"},{"content":" Java Roadmap for 2024 by Nelson TBC\u0026hellip; ","permalink":"https://jrmh.dev/editors-picks/java/","summary":" Java Roadmap for 2024 by Nelson TBC\u0026hellip; ","title":"Java"}]